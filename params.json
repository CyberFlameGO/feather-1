{"name":"Feather","tagline":"Lightweight dependency injection for Java and Android (JSR-330)","body":"####About Feather####\r\nFeather is an ultra-lightweight dependency injection ([JSR-330](https://jcp.org/en/jsr/detail?id=330 \"JSR-330\"))\r\nlibrary for Java and Android. Dependency injection frameworks are often perceived as \"magical\" and complex. \r\nFeather - with just a few hundred lines of code - is probably the easiest, tiniest, most obvious one, \r\nand is quite efficient too (see comparison section below).\r\n```xml\r\n<dependency>\r\n    <groupId>org.codejargon.feather</groupId>\r\n    <artifactId>feather</artifactId>\r\n    <version>1.0</version>\r\n</dependency>\r\n```\r\n[Javadoc](http://zsoltherpai.github.io/feather/apidocs \"Javadoc\") for Feather\r\n#####Usage - code examples#####\r\n######Create Feather (the injector)######\r\n```java\r\nFeather feather = Feather.with();\r\n```\r\nAn application typically needs a single Feather instance.\r\n\r\n######Instantiating dependencies######\r\nDependencies with @Inject constructor or a default constructor can be injected by Feather without the need for\r\nany configuration. Eg:\r\n```java\r\npublic class A {\r\n    @Inject\r\n    public A(B b) {\r\n        // ...\r\n    }\r\n}\r\n\r\npublic class B {\r\n    @Inject\r\n    public B(C c, D d) {\r\n        // ...\r\n    }\r\n}\r\n\r\npublic class C {}\r\n\r\n@Singleton\r\npublic class D {\r\n    // something expensive or other reasons for being singleton\r\n}\r\n```\r\nCreating an instance of A:\r\n```java\r\nA a = feather.instance(A.class);\r\n```\r\n######Providing additional dependencies to Feather######\r\nWhen injecting an interface, a 3rd party class or an object needing custom instantiation, Feather relies on configuration\r\nmodules providing those dependencies:\r\n```java\r\npublic class MyModule {\r\n    @Provides\r\n    @Singleton // an app will probably need a single instance \r\n    DataSource ds() {\r\n        DataSource dataSource = // instantiate some DataSource\r\n        return dataSource;\r\n    }\r\n}\r\n```\r\nSetting up Feather with module(s):\r\n```java\r\nFeather feather = Feather.with(new MyModule());\r\n```\r\nThe DataSource dependency will now be available for injection:\r\n```java\r\npublic class MyApp {\r\n    @Inject \r\n    public MyApp(DataSource ds) {\r\n        // ...\r\n    }\r\n}\r\n```\r\nFeather injects dependencies to @Provides methods aguments. This is particularly useful for binding an implementation\r\nto an interface:\r\n```java\r\npublic interface Foo {}\r\n\r\npublic class FooBar implements Foo {\r\n    @Inject\r\n    public FooBar(X x, Y y, Z z) {\r\n        // ...\r\n    }\r\n}\r\n\r\npublic class MyModule {\r\n    @Provides\r\n    Foo foo(FooBar fooBar) {\r\n        return fooBar;\r\n    }\r\n}\r\n\r\n// injecting an instance of Foo interface will work using the MyModule above:\r\npublic class A {\r\n    @Inject\r\n    public A(Foo foo) {\r\n        // ...\r\n    }\r\n}\r\n```\r\nNote that the @Provides method serves just as a binding declaration here, no manual instantiation needed\r\n######Qualifiers######\r\nFeather supports Qualifiers (@Named or custom qualifiers)\r\n```java\r\npublic class MyModule {\r\n    @Provides\r\n    @Named(\"greeting\")\r\n    String greeting() {\r\n        return \"hi\";\r\n    }\r\n        \r\n    @Provides\r\n    @SomeQualifier\r\n    Foo some(FooSome fooSome) {\r\n        return fooSome;\r\n    };\r\n}\r\n```\r\nInjecting:\r\n```java\r\npublic class A {\r\n    @Inject\r\n    public A(@SomeQualifier Foo foo, @Named(\"greeting\") String greet) {\r\n        // ...\r\n    }\r\n}\r\n```\r\nOr directly from feather:\r\n```java\r\nString greet = feather.instance(String.class, \"greeting\");\r\nFoo foo = feather.instance(Key.of(Foo.class, SomeQualifier.class));\r\n```\r\n######Provider injection######\r\nFeather injects [Provider](https://docs.oracle.com/javaee/6/api/javax/inject/Provider.html)s  to facilitate lazy loading or circular dependencies:\r\n```java\r\npublic class A {\r\n    @Inject\r\n    public A(Provider<B> b) {\r\n        B b = b.get(); // fetch a new instance when needed\r\n    }\r\n}\r\n```\r\nOr getting a Provider directly from Feather:\r\n```java\r\nProvider<B> bProvider = feather.provider(B.class);\r\n```\r\n######Override modules######\r\n```java\r\npublic class Module {\r\n    @Provides\r\n    DataSource dataSource() {\r\n        // return a mysql datasource\r\n    }\r\n    \r\n    // other @Provides methods\r\n}\r\n\r\npublic class TestModule extends Module {\r\n    @Override\r\n    @Provides\r\n    DataSource dataSource() {\r\n        // return a h2 datasource\r\n    }\r\n}\r\n```\r\n######Field injection######\r\nFeather supports Constructor injection only when injecting to a dependency graph. It inject fields also if it's\r\nexplicitly triggered for a target object - eg to facilitate testing. A simple example with a junit test:\r\n```java\r\npublic class AUnitTest {\r\n    @Inject\r\n    private Foo foo;\r\n    @Inject\r\n    private Bar bar;\r\n\r\n    @Before\r\n    public void setUp() {\r\n        Feather feather = // obtain a Feather instance\r\n        feather.injectFields(this);\r\n    }\r\n}\r\n```\r\n######Method injection######\r\nNot supported. The need for it can be generally avoided by a Provider / solid design (favoring immutability, injection via constructor).\r\n\r\n#####Android example#####\r\n```java\r\nclass ExampleApplication extends Application {\r\n    private Feather feather;\r\n\r\n    @Override public void onCreate() {\r\n        // ...\r\n        feather = Feather.with( /* modules if needed*/ );\r\n    }\r\n\r\n    public Feather feather() {\r\n        return feather;\r\n    }\r\n}\r\n\r\nclass ExampleActivity extends Activity {\r\n    @Inject\r\n    private Foo foo;\r\n    @Inject\r\n    private Bar bar;\r\n\r\n  @Override public void onCreate(Bundle savedState) {\r\n    // ...\r\n    ((ExampleApplication) getApplication())\r\n        .feather()\r\n            .injectFields(this);\r\n  }\r\n}\r\n```\r\nFor best possible performance, dependencies should be immutable and @Singleton. See full example in android-test.\r\n#####Footprint, performance, comparison#####\r\nSmall footprint and high performance is in Feather's main focus.\r\n- compared to [Guice] (https://github.com/google/guice \"Guice\"): 1/50 the library size, ~10x startup speed\r\n- compared to [Dagger](http://square.github.io/dagger): 1/4 the library size (of just Dagger's run-time part), ~2x startup speed\r\n\r\nNote: startup means creation of the container and instantiation of an object graph. Executable comparison including Spring, \r\nGuice, Dagger, PicoContainer is in 'performance-test' module.\r\n\r\n#####How it works under the hood#####\r\nFeather is based on optimal use of reflection to provide dependencies. No code generating, classpath scanning, proxying or anything\r\ncostly involved.\r\n\r\nA simple example with some explanation:\r\n```java\r\nclass A {\r\n    @Inject\r\n    A(B b) {\r\n\r\n    }\r\n}\r\n\r\nclass B {\r\n\r\n}\r\n```\r\nWithout the use of Feather, class A could be instantiated with the following factory methods:\r\n```java\r\nA a() {\r\n    return new A(b());\r\n}\r\n\r\nB b() {\r\n    return new B();\r\n}\r\n```\r\nFeather avoids the need for writing such factories - by doing the same thing internally: When an instance of A is injected,\r\nFeather calls A's constructor with the necessary arguments - an instance of B. That instance of B is created the same way \r\n\\- a simple recursion, this time with no further dependencies \\- and the instance of A is created.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}